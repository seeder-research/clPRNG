#include "clPRNG.hpp"

// Main C interface functions

// Main call to create a stream object
CLPRNG_DLL ClPRNG* clPRNG_create_stream() {
    return new ClPRNG;
}

// Main call to generate stream in the stream object
CLPRNG_DLL cl_int clPRNG_generate_stream(ClPRNG* p, int count, cl_mem dst) {
    if (count < 0) {
        std::cout << "ERROR: count must be a positive integer!" << std::endl;
        return -1;
    }
    cl_int err;
    if (p->IsInitialized() && p->IsSourceReady() && p->IsProgramReady() && p->IsSeeded() == false) {
        std::cout << "ERROR: stream is not fully ready!" << std::endl;
        return -2;
    }
    for (; count > 0;) {
        if ((count == 0) || (dst == NULL)) {
            break;
        }
        if (p->GetNumValidEntries() <= 0) {
            if (p->GetStateOfStateBuffer() == false) {
                err = p->CopyStateToDevice();
                if (err != 0) {
                    return err;
                }
            }
            err = p->FillBuffer();
            if (err != 0) {
                std::cout << "ERROR: unable to generate random bit stream!" << std::endl;
                if (p->GetStateOfStateBuffer()) {
                    err = p->CopyStateToHost();
                    if (err != 0) {
                        return err;
                    }
                }
                return err;
            }
            p->SetNumValidEntries(p->GetNumBufferEntries());
            p->SetBufferOffset(0);
        }
        size_t dst_offset = 0;
        if (count <= p->GetNumValidEntries()) {
	    err = p->CopyBufferEntries(dst, dst_offset, (size_t)(count));
            if (err != 0) {
                std::cout << "ERROR: unable to copy random bit stream from buffer to dst!" << std::endl;
                if (p->GetStateOfStateBuffer()) {
                    err = p->CopyStateToHost();
                    if (err != 0) {
                        return err;
                    }
                }
                return err;
            }
            p->SetNumValidEntries(p->GetNumValidEntries() - count);
            p->SetBufferOffset(count + p->GetBufferOffset());
            break;
        } else {
	    err = p->CopyBufferEntries(dst, dst_offset, p->GetNumValidEntries());
	    if (err != 0) {
                if (p->GetStateOfStateBuffer()) {
                    err = p->CopyStateToHost();
                    if (err != 0) {
                        return err;
                    }
                }
	        return err;
	    }
            count -= p->GetNumValidEntries();
            dst_offset += p->GetNumValidEntries();
            p->SetNumValidEntries(0);
        }
    }
    if (p->GetStateOfStateBuffer()) {
        err = p->CopyStateToHost();
        if (err != 0) {
            return err;
        }
    }
    return err;
}

// Main call to initialize the stream object
CLPRNG_DLL void initialize_prng(ClPRNG* p, cl_device_id dev_id, const char *name) {
    (*p).Init(dev_id, name);
}

// Main call to generate the kernel program in the stream project
CLPRNG_DLL cl_int buildPRNGKernelProgram(ClPRNG* p) {
    (*p).BuildSource();
    return (*p).BuildKernelProgram();
}

// Default constructor
ClPRNG::ClPRNG() {
    device = 0;
    context = 0;
    com_queue = 0;
    total_count = 0;
    valid_count = 0;
    seedVal = 0;
    offset = 0;
    local_state_mem = NULL;
    wkgrp_size = 0;
    wkgrp_count = 0;
    init_flag = false;
    source_ready = false;
    rng_name = "mt19937";
    rng_precision = "ulong";
    rng_source = "";
}

// Default destructor
ClPRNG::~ClPRNG() {
}

// Internal function to initialize the stream object
void ClPRNG::Init(cl_device_id dev_id, const char *name) {
    this->device_id = dev_id;
    this->device = device_id;
    cl_int err;
    this->context_id = clCreateContext(NULL, 1, &device_id, NULL, NULL, &err);
    if (err) {
        std::cout << "ERROR: Unable to create context!" << std::endl;
        return;
    }
    this->context = context_id;
    this->com_queue_id = clCreateCommandQueue(context_id, device_id, NULL, &err);
    if (err) {
        std::cout << "ERROR: Unable to create command queue!" << std::endl;
        return;
    }
    this->com_queue = com_queue_id;
    this->rng_name = name;
    this->rng_precision = "uint";
    this->init_flag = true;
    this->source_ready = false;
    this->program_ready = false;
}

// Internal function to set the precision of the random
// numbers generated by the stream object
int ClPRNG::SetPrecision(const char * precision) {
    this->source_ready = false;
    this->program_ready = false;
    std::string str = std::string(precision);
    if ((str == "uint") || (str == "ulong") || (str == "float") || (str == "double")) {
        this->rng_precision = precision;
    } else {
        fprintf(stderr, "Can only generate numbers of types: uint, ulong, float, double!");
        return -1;
    }
    return 0;
}

// Internal function that maps RNG names to an integer id
int ClPRNG::LookupPRNG(std::string name) {
    if (name == "isaac") {
        return 1;
    } else if (name == "kiss09") {
        return 2;
    } else if (name == "kiss99") {
        return 3;
    } else if (name == "lcg6432") {
        return 4;
    } else if (name == "lcg12864") {
        return 5;
    } else if (name == "lfib") {
        return 6;
    } else if (name == "mrg31k3p") {
        return 7;
    } else if (name == "mrg63k3a") {
        return 8;
    } else if (name == "msws") {
        return 9;
    } else if (name == "mt19937") {
        return 10;
    } else if (name == "mwc64x") {
        return 11;
    } else if (name == "pcg6432") {
        return 12;
    } else if (name == "philox2x32_10") {
        return 13;
    } else if (name == "ran2") {
        return 14;
    } else if (name == "tinymt32") {
        return 15;
    } else if (name == "tinymt64") {
        return 16;
    } else if (name == "tyche") {
        return 17;
    } else if (name == "tyche_i") {
        return 18;
    } else if (name == "well512") {
        return 19;
    } else if (name == "xorshift1024") {
        return 20;
    } else if (name == "xorshift6432star") {
        return 21;
    } else {
        return -1;
    }
    return -1;
}

// Internal function to generate the kernel codes for the PRNGs
void ClPRNG::generateBufferKernel(std::string name, std::string type, std::string src) {
    static std::string tmp = std::string((type=="double") ? " #pragma OPENCL EXTENSION cl_khr_fp64 : enable \n" : "");
    switch(this->LookupPRNG(name)) {
        case 1 :
            tmp += isaac_prng_kernel;
            break;
        case 2 :
            tmp += kiss09_prng_kernel;
            break;
        case 3 :
            tmp += kiss99_prng_kernel;
            break;
        case 4 :
            tmp += lcg6432_prng_kernel;
            break;
        case 5 :
            tmp += lcg12864_prng_kernel;
            break;
        case 6 :
            tmp += lfib_prng_kernel;
            break;
        case 7 :
            tmp += mrg31k3p_prng_kernel;
            break;
        case 8 :
            tmp += mrg63k3a_prng_kernel;
            break;
        case 9 :
            tmp += msws_prng_kernel;
            break;
        case 10 :
            tmp += mt19937_prng_kernel;
            break;
        case 11 :
            tmp += mwc64x_prng_kernel;
            break;
        case 12 :
            tmp += pcg6432_prng_kernel;
            break;
        case 13 :
            tmp += philox2x32_10_prng_kernel;
            break;
        case 14 :
            tmp += ran2_prng_kernel;
            break;
        case 15 :
            tmp += tinymt32_prng_kernel;
            break;
        case 16 :
            tmp += tinymt64_prng_kernel;
            break;
        case 17 :
            tmp += tyche_prng_kernel;
            break;
        case 18 :
            tmp += tyche_i_prng_kernel;
            break;
        case 19 :
            tmp += well512_prng_kernel;
            break;
        case 20 :
            tmp += xorshift1024_prng_kernel;
            break;
        case 21 :
            tmp += xorshift6432star_prng_kernel;
            break;
        default :
            std::cout << "Unknown PRNG. No implementation found!" << std::endl;
            break;
    }
    switch(this->LookupPRNG(name)) {
        case 20 :
            tmp += "\n"
                   "kernel void seed_prng_by_value(ulong seedVal, global " + name + "_state* state){\n"
                   "    uint gid=get_global_id(0);\n"
                   "    ulong seed = seedVal<<1;\n"
                   "    if (seed == 0) {\n"
                   "        seed += 1;\n"
                   "    }\n"
                   "\n"
                   "    " + name + "_seed(state,seed);\n"
                   "}";
                   "\n"
                   "kernel void seed_prng_by_array(global ulong* seedArr, global " + name + "_state* state){\n"
                   "    uint gid=get_global_id(0);\n"
                   "    ulong seed = seedArr[gid];\n"
                   "\n"
                   "    " + name + "_seed(state,seed);\n"
                   "}";
                   "\n"
                   "kernel void generate(uint num, global ulong* seed, global " + type + "* res, global " + name + "_state* stateBuf, local " + name + "_state* state){\n"
                   "    uint gid=get_global_id(0);\n"
                   "    uint gsize=get_global_size(0);\n"
                   "\n"
                   "    state = stateBuf;\n"
                   "    uint num_gsize = ((num - 1) / gsize + 1)*gsize; //next multiple of gsize, larger or equal to N\n"
                   "    for (int i = gid; i<num_gsize; i += gsize) {\n"
                   "        " + type + " val = " + name + "_" + type + "(state); //all threads within workgroup must call generator, even if result is not needed!\n"
                   "        if (i<num) {\n"
                   "            res[i] = val;\n"
                   "        }\n"
                   "    }\n"
                   "}";
                   break;
        default :
            tmp += "\n"
                   "kernel void seed_prng_by_value(ulong seedVal, global " + name + "_state* stateBuf){\n"
                   "    uint gid=get_global_id(0);\n"
                   "    ulong seed = seedVal<<1;\n"
                   "    if (seed == 0) {\n"
                   "        seed += 1;\n"
                   "    }\n"
                   "    " + name + "_state state;\n"
                   "    " + name + "_seed(&state,seed);\n"
                   "    stateBuf[gid] = state;\n"
                   "}"
                   "\n"
                   "kernel void seed_prng_by_array(global ulong* seedArr, global " + name + "_state* stateBuf){\n"
                   "    uint gid=get_global_id(0);\n"
                   "    ulong seed = seedArr[gid];\n"
                   "    " + name + "_state state;\n"
                   "    " + name + "_seed(&state,seed);\n"
                   "    stateBuf[gid] = state;\n"
                   "}"
                   "\n"
                   "kernel void generate(uint num, global " + name + "_state* stateBuf, global " + type + "* res){\n"
                   "    uint gid=get_global_id(0);\n"
                   "    uint gsize=get_global_size(0);\n"
                   "    " + name + "_state state;\n"
                   "    state = stateBuf[gid];\n"
                   "    for(uint i=gid;i<num;i+=gsize){\n"
                   "        res[i]=" + name + "_" + type + "(state);\n"
                   "    }\n"
                   "    stateBuf[gid] = state;\n"
                   "}";
                   break;
    }
    src = tmp;
}

// Internal function to build the kernel source codes
// for the program of the stream object
void ClPRNG::BuildSource() {
    this->source_ready = false;
    std::string &kernel_src = rng_source;
    this->generateBufferKernel(std::string(rng_name), std::string(rng_precision), kernel_src);
    this->source_ready = true;
}

// Internal function to compile and link the kernel source
// codes into the program of the stream object
cl_int ClPRNG::BuildKernelProgram() {
    this->program_ready = false;
    cl_int err;
    if (init_flag && source_ready) {
        cl::Program::Sources sources(1, std::make_pair(rng_source.c_str(), rng_source.length()));
        this->rng_program = cl::Program(context, sources);
        std::string build_args = "-cl-std=CL1.2 -cl-kernel-arg-info";
        err = this->rng_program.build(std::vector<cl::Device>({device}), build_args.c_str());
        if (err) {
            std::cout << "ERROR: Unable to build PRNG program!" << std::endl;
            return err;
        }
        this->seed_rng = cl::Kernel(rng_program, "seed_prng");
        this->generate_bitstream = cl::Kernel(rng_program, "generate");
        this->program_ready = true;
        return err;
    }
    std::cout << "ERROR: Stream object not initialized or kernel source code has not been built!" << std::endl;
    return -1;
}

// Internal function that is the second phase of the initialization step.
// The number of workitems per workgroup supported by the device is
// discovered. The buffers of the PRNG are created to support the number
// of workitems that can be launched in parallel. The kernel launch
// configuration is also built
cl_int ClPRNG::ReadyGenerator() {
    // Query number of workitems and workgroups supported by the device
    cl_int err;
    err = this->device.getInfo<cl_uint>(CL_DEVICE_MAX_WORK_GROUP_SIZE, &this->wkgrp_size);
    if (err) {
        std::cout << "ERROR: failed to get max workgroup size on device!" << std::endl;
        return err;
    }
    err = this->device.getInfo<cl_uint>(CL_DEVICE_MAX_COMPUTE_UNITS, &this->wkgrp_count);
    if (err) {
        std::cout << "ERROR: failed to get max number of compute unites on device!" << std::endl;
        return err;
    }

    // Upper limit for number of workitems per workgroup is set at 256...
    if (this->wkgrp_size > 256) {
        this->wkgrp_size = 256;
    }

    // Upper limit for number of workitems per workgroup is lowered if
    // the PRNG is based on xorshift1024
    if (std::string(this->rng_name) == "xorshift1024") {
        this->wkgrp_size = 32;
    }

    // Determine the number of bytes for each random number generated
    // by a workitem
    size_t typeSize = 4;
    if (std::string(this->rng_precision) == "uint") {
        typeSize = 2;
    } else if (std::string(this->rng_precision) == "double") {
        typeSize = 8;
    } else {
        std::cout << "ERROR: Unknown rng_precision detected!" << std::endl;
        return -1;
    }

    // Create the buffer storing the states of the PRNGs
    this->SetStateSize();
    size_t stateBufSize = (size_t)(this->wkgrp_count * this->wkgrp_size) * this->state_size;
    this->stateBuffer_id = clCreateBuffer(this->context_id, CL_MEM_READ_WRITE, stateBufSize, NULL, &err);
    if (err) {
        std::cout << "ERROR: Unable to create state buffer or PRNG!" << std::endl;
        return err;
    }
    this->stateBuffer = stateBuffer_id;

    // Create the temporary buffer in which random numbers are generated.
    // These numbers will be copied to the desired destination when required.
    size_t outBufSize = (size_t)(this->wkgrp_count * this->wkgrp_size) * typeSize;
    this->tmpOutputBuffer_id = clCreateBuffer(this->context_id, CL_MEM_READ_WRITE, outBufSize, NULL, &err);
    if (err) {
        std::cout << "ERROR: Unable to create temporary buffer or PRNG!" << std::endl;
        return err;
    }
    this->tmpOutputBuffer = tmpOutputBuffer_id;

    // At this point the buffers are set up...
    // TODO:
    // 1) Call (public) function to set the seed value
    // 2) Call (private) function to initialize the PRNG states and save in stateBuffer
    // 3) Call (private) function to generate a set of random numbers to fill the temporary buffer
    // 4) Initialize the counters that tracks available random numbers
    return err;
}

// Function to set the size of the state for each PRNG
void ClPRNG::SetStateSize() {
    switch(LookupPRNG(std::string(rng_name)))
    {
        case 1:
            this->state_size = sizeof(isaac_state);
            break;
        case 2:
            this->state_size = sizeof(kiss09_state);
            break;
        case 3:
            this->state_size = sizeof(kiss99_state);
            break;
        case 4:
            this->state_size = sizeof(lcg6432_state);
            break;
        case 5:
            this->state_size = sizeof(lcg12864_state);
            break;
        case 6:
            this->state_size = sizeof(lfib_state);
            break;
        case 7:
            this->state_size = sizeof(mrg31k3p_state);
            break;
        case 8:
            this->state_size = sizeof(mrg63k3a_state);
            break;
        case 9:
            this->state_size = sizeof(msws_state);
            break;
        case 10:
            this->state_size = sizeof(mt19937_state);
            break;
        case 11:
            this->state_size = sizeof(mwc64x_state);
            break;
        case 12:
            this->state_size = sizeof(pcg6432_state);
            break;
        case 13:
            this->state_size = sizeof(philox2x32_10_state);
            break;
        case 14:
            this->state_size = sizeof(ran2_state);
            break;
        case 15:
            this->state_size = sizeof(tinymt32_state);
            break;
        case 16:
            this->state_size = sizeof(tinymt64_state);
            break;
        case 17:
            this->state_size = sizeof(tyche_state);
            break;
        case 18:
            this->state_size = sizeof(tyche_i_state);
            break;
        case 19:
            this->state_size = sizeof(well512_state);
            break;
        case 20:
            this->state_size = sizeof(xorshift1024_state);
            break;
        case 21:
            this->state_size = sizeof(xorshift6432star_state);
            break;
        default :
            this->state_size = 0;
            break;
    }
}

// Sets the current offset of the temporary buffer store
// Entries preceding the offset are invalid
void ClPRNG::SetBufferOffset(size_t ptr) {
    if ((std::string)(this->rng_precision) == "double") {
        this->offset = ptr * 8;
    } else {
        this->offset = ptr * 4;
    }
}

// Returns the current offset of the temporary buffer
size_t ClPRNG::GetBufferOffset() {
    if ((std::string)(this->rng_precision) == "double") {
        return (this->offset / 8);
    }
    return (this->offset / 4);
}

// Function to copy random numbers from temporary buffer to desired destination
cl_int ClPRNG::CopyBufferEntries(cl_mem dst, size_t dst_offset, size_t count) {
    size_t numBytes = 4;
    if ((std::string)(this->rng_precision) == "double") {
        numBytes = 8;
    }

    // Copy buffer data in device
    cl_event eventFlag;
    cl_int err = clEnqueueCopyBuffer(this->com_queue_id, this->tmpOutputBuffer_id, dst, this->offset, dst_offset * numBytes, count * numBytes, 0, NULL, &eventFlag);
    if (err != 0) {
        std::cout << "ERROR: unable to copy buffer entries in CopyBufferEntries!" << std::endl;
        return err;
    }

    // Wait for copy in device side to complete before returning
    err = clWaitForEvents(1, &eventFlag);
    if (err != 0) {
        std::cout << "ERROR: unable to wait for copy buffer to complete in CopyBufferEntries!" << std::endl;
        return err;
    }
    return err;
}

// Internal function that seeds the PRNGs in the
// stream object
cl_int ClPRNG::SeedGenerator() {
    this->seeded = false;
    if (this->init_flag != true) {
        std::cout << "ERROR: stream object has not been initialized!" << std::endl;
        return -1;
    }
    if (this->source_ready != true) {
        std::cout << "ERROR: source for stream object has not been built!" << std::endl;
        return -2;
    }
    if (this->program_ready != true) {
        std::cout << "ERROR: kernel programs for stream object has not been built!" << std::endl;
        return -3;
    }
    cl_int err;
    err = this->seed_rng.setArg(0, (const ulong)(this->seedVal));
    if (err != 0) {
        std::cout << "ERROR: Unable to set first argument to kernel to seed PRNG!" << std::endl;
        return err;
    }
    err = seed_rng.setArg(1, this->stateBuffer);
    if (err != 0) {
        std::cout << "ERROR: Unable to set second argument to kernel to seed PRNG!" << std::endl;
        return err;
    }
    cl_event event_id;
    cl::Event event;
    err = this->com_queue.enqueueNDRangeKernel(this->seed_rng, cl::NDRange(0), cl::NDRange((size_t)(this->wkgrp_count * this->wkgrp_size)), cl::NDRange((size_t)(this->wkgrp_size)), NULL, &event);
    if (err != 0) {
        std::cout << "ERROR: Unable to enqueue kernel to seed PRNG!" << std::endl;
        return err;
    }
    std::vector<cl::Event> eventList = { event };
    err = cl::WaitForEvents(eventList);
    if (err != 0) {
        std::cout << "ERROR: Unable to wait for kernel to seed PRNG!" << std::endl;
        return err;
    }
    if (local_state_mem == NULL) {
        static void *tmp_mem = malloc(state_size * (size_t)(this->wkgrp_size * this->wkgrp_count));
        this->local_state_mem = tmp_mem;
    } else {
        free(this->local_state_mem);
        static void *tmp_mem = malloc(state_size * (size_t)(this->wkgrp_size * this->wkgrp_count));
        this->local_state_mem = tmp_mem;
    }
    err = this->com_queue.enqueueReadBuffer(this->stateBuffer, true, 0, this->state_size * (size_t)(this->wkgrp_size * this->wkgrp_count), this->local_state_mem, NULL, &event);
    if (err != 0) {
        std::cout << "ERROR: Unable to copy PRNG state from device back to host!" << std::endl;
        return err;
    }
    err = cl::WaitForEvents(eventList);
    if (err != 0) {
        std::cout << "ERROR: Unable to wait for copying PRNG state from device to host!" << std::endl;
        return err;
    }
    this->seeded = true;
    return err;
}


// Internal function that copies the PRNG states from
// host side to device side
cl_int ClPRNG::CopyStateToDevice() {
    // Copy PRNG states from host side to device side
    cl::Event event;
    cl_int err = this->com_queue.enqueueWriteBuffer(this->stateBuffer, true, 0, this->state_size * (size_t)(this->wkgrp_count * this->wkgrp_size), this->local_state_mem, NULL, &event);
    if (err != 0) {
        std::cout << "ERROR: unable to copy state from host to device!" << std::endl;
        return err;
    }
    std::vector<cl::Event> eventList = { event };
    err = cl::WaitForEvents(eventList);
    if (err != 0) {
        std::cout << "ERROR: unable to wait for copy state from host to device to finish!" << std::endl;
        return err;
    }

}

// Internal function that copies the PRNG states from
// device side to host side
cl_int ClPRNG::CopyStateToHost() {
    // Copy PRNG states from device side back to host side
    cl::Event event;
    cl_int err = this->com_queue.enqueueReadBuffer(this->stateBuffer, true, 0, this->state_size * (size_t)(this->wkgrp_count * this->wkgrp_size), this->local_state_mem, NULL, &event);
    if (err != 0) {
        std::cout << "ERROR: unable to copy state from host to device!" << std::endl;
        return err;
    }
    std::vector<cl::Event> eventList = { event };
    err = cl::WaitForEvents(eventList);
    if (err != 0) {
        std::cout << "ERROR: unable to wait for copy state from host to device to finish!" << std::endl;
        return err;
    }
    return err;
}

// Internal function that generates random stream
// in the stream object by calling the kernel.
cl_int ClPRNG::FillBuffer() {
    // Set up kernel to generate random bitstream
    cl_int err = this->generate_bitstream.setArg(0, this->total_count);
    if (err != 0) {
        std::cout << "ERROR: Unable to set first argument to kernel to generate bitstream!" << std::endl;
        return err;
    }
    err = this->generate_bitstream.setArg(1, this->stateBuffer);
    if (err != 0) {
        std::cout << "ERROR: Unable to set second argument to kernel to generate bitstream!" << std::endl;
        return err;
    }
    err = this->generate_bitstream.setArg(2, this->tmpOutputBuffer);
    if (err != 0) {
        std::cout << "ERROR: Unable to set third argument to kernel to generate bitstream!" << std::endl;
        return err;
    }

    // Execute kernel to generate random bitstream
    cl::Event event;
    err = this->com_queue.enqueueNDRangeKernel(this->generate_bitstream, cl::NDRange(0), cl::NDRange((size_t)(this->wkgrp_count * this->wkgrp_size)), cl::NDRange((size_t)(this->wkgrp_size)), NULL, &event);
    if (err != 0) {
        std::cout << "ERROR: Unable to enqueue kernel to generate bitstream!" << std::endl;
        return err;
    }
    std::vector<cl::Event> eventList = { event };
    err = cl::WaitForEvents(eventList);
    if (err != 0) {
        std::cout << "ERROR: unable to wait for copy state from host to device to finish!" << std::endl;
    }
    return err;
}

void ClPRNG::SetSeed(ulong seed) {
    this->seedVal = seed;
    this->seeded = false;
}
